#!/usr/bin/env python
# vim: set fileencoding=utf-8:

"""Multi-user chat server for the MUC web interface.

Reads messages of the "nickname text..." form from a fifo, spawns a new client
for each new nickname, sends the messages out.

Configuration is read from ~/.jcserver, which must be a text file containing 4
words: your jid, jabber password, jabber chat room and the fifo to use.  Example:

  alice@example.com secret tmradio@conference.jabber.ru /tmp/jcserver.fifo

To send a message:

  echo "alice_1 hello, world." > /tmp/jcserver.fifo

To shut down the server press ^C.

This version uses JabberBot from the ardj package.  To run without installing
the package use this command:

  PYTHONPATH=../ ./jcserver
"""

import cgi
import os
import socket
import sys
import threading
import time
import xmpp
import BaseHTTPServer

JABBER_LOGIN = None
JABBER_PASSWORD = None
JABBER_NICK = 'chat-server'
JABBER_CHAT_ROOM = None
JABBER_FIFO = None
JABBER_TIMEOUT = 600

shutting_down = False

class client(threading.Thread):
    def __init__(self, nickname, on_end):
        threading.Thread.__init__(self)
        self.__nickname = nickname
        self.__on_end = on_end
        self.__messages = [None, None] # some delay
        self.__jid = None
        self.__conn = None
        self.__lastmsg = time.time()
        self.__shutdown = False

        self.start()

    def post_message(self, message):
        self.__messages.append(message)

    def run(self):
        print 'Client %s thread started.' % self.__nickname

        self.__jid = xmpp.JID(JABBER_LOGIN)
        self.__conn = self.connect()
        self.__join()

        global shutting_down
        while not self.__shutdown and not shutting_down:
            try:
                self.__conn.Process(1)

                if time.time() - self.__lastmsg > JABBER_TIMEOUT:
                    print '%s timed out' % self.__nickname
                    self.__shutdown = True
                elif self.__messages:
                    self.__talk(self.__messages.pop())
            except KeyboardInterrupt:
                shutdown = True

        print 'Client %s thread stopped.' % self.__nickname
        self.__on_end()

    def connect(self):
        conn = xmpp.Client(self.__jid.getDomain(), debug=[])

        conres = conn.connect()
        if not conres:
            self.log.error('unable to connect to server %s.' % self.__jid.getDomain())
            return None
        if conres <> 'tls':
            self.log.warning('unable to establish secure connection - TLS failed!')

        authres = conn.auth(self.__jid.getNode(), JABBER_PASSWORD, self.__nickname)
        if not authres:
            self.log.error('unable to authorize with server.')
            return None
        if authres <> 'sasl':
            self.log.warning("unable to perform SASL auth os %s. Old authentication method used!" % self.__jid.getDomain())

        conn.sendInitPresence()
        return conn

    def __join(self):
        self.__conn.send(xmpp.Presence(JABBER_CHAT_ROOM + u'/' + self.__nickname))

    def __leave(self):
        msg = xmpp.Presence()
        msg.setTo(JABBER_CHAT_ROOM + u'/' + self.__nickname)
        msg.setType('unavailable')
        self.__conn.send(msg)

    def __talk(self, text):
        if text:
            msg = xmpp.protocol.Message(body=text)
            msg.setTo(JABBER_CHAT_ROOM)
            msg.setType('groupchat')
            self.__conn.send(msg)


class server:
    def __init__(self):
        self.clients = {}

    def run(self):
        try:
            while True:
                nickname, message = self.read()
                if nickname and message:
                    self.on_message(nickname, message)
        finally:
            self.shutdown()

    def on_message(self, nickname, message):
        if not self.clients.has_key(nickname):
            self.clients[nickname] = client(nickname, on_end=lambda: self.detach(nickname))
        self.clients[nickname].post_message(message)

    def shutdown(self):
        pass

    def detach(self, nickname):
        if self.clients.has_key(nickname):
            print 'Detaching %s' % nickname
            del self.clients[nickname]


class fifo_server(server):
    def __init__(self):
        server.__init__(self)

        fname = JABBER_FIFO
        if os.path.exists(fname):
            os.unlink(fname)
        os.mkfifo(fname)
        self.f = open(fname, 'rb')

    def read(self):
        nickname, message = None, None
        data = self.f.read(1024)
        if data:
            parts = data.strip().split(' ', 1)
            if len(parts) == 2:
                nickname, message = parts
        return nickname, message

    def shutdown(self):
        fname = JABBER_FIFO
        if os.path.exists(fname):
            os.unlink(fname)


class http_server(server):
    u"""HTTP version.

    To send a test message:
    curl --data 'nickname=umonkey_1&message=hello,+world.' http://localhost:8000/
    """
    def __init__(self):
        server.__init__(self)
        self.httpd = BaseHTTPServer.HTTPServer(('', 8000), http_request_handler)
        self.httpd.on_message = self.on_message

    def run(self):
        self.httpd.serve_forever()


class http_request_handler(BaseHTTPServer.BaseHTTPRequestHandler):
    def __init__(self, addr, handler, server):
        BaseHTTPServer.BaseHTTPRequestHandler.__init__(self, addr, handler, server)
        self.server = server

    def do_POST(self, *args, **kwargs):
        form = cgi.FieldStorage(fp=self.rfile, headers=self.headers, environ={'REQUEST_METHOD':'POST', 'CONTENT_TYPE':self.headers['Content-Type']})
        self.server.on_message(form['nickname'].value, form['message'].value)
        self.send_response(200, 'OK')
        self.end_headers()
        self.wfile.write('OK\n')


if __name__ == '__main__':
    data = open(os.path.expanduser('~/.jcserver'), 'rb').read().strip().split(' ')
    JABBER_LOGIN, JABBER_PASSWORD, JABBER_CHAT_ROOM, JABBER_FIFO = data[0:4]

    try:
        http_server().run()
    except KeyboardInterrupt:
        shutting_down = True
