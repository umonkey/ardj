#!/usr/bin/env python
# vim: set fileencoding=utf-8:
#
# Retrieves messages from a mailbox, retrieves attachments and passes them to
# an external program.  Designed to be set up as a cron job.
#
# Reads the "voicemailer" section of ardj.yaml, must look like this:
#
# voicemailer:
#   host: pop.gmail.com
#   login: john.doe
#   password: secret
#   to: voice@example.com
#
# With these settings the script will connect to the mailbox for user john.doe
# at Gmail, find all messages addressed to voice@example.com, extract audio
# files and pass them to the ./voicemail.sh command.
#
# If you want to only process messages that have a certain word in the subject
# line, define it as "subject: keyword".
#
# Don't forget to chmod 600 voicemail.conf after you create it, as it contains
# your mailbox password.
#
# To add intro and outro, create files voicemail-pre.wav and voicemail-post.wav
# in ~/.config/tmradio, also make sure that sox is installed (it's used to
# concat sound files).

import email.header
import email.parser
import email.utils
import logging
import mutagen
import os
import poplib
import re
import rfc822
import subprocess
import sys
import time
import tempfile
import traceback
import yaml

import ardj.settings

TMPREFIX = time.strftime('vm-%y%m%d-')

settings = None

def log(message):
    print >>sys.stderr, message

def run(command):
    log('exec: ' + ' '.join(command))
    subprocess.Popen(command).wait()

def decode_subject(header):
    decode_part = lambda x: x[1] and x[0].decode(x[1]) or x[0]
    subject = u' '.join([decode_part(x) for x in email.header.decode_header(header)]).strip()
    if settings is not None and settings.has_key('subject'):
        subject = subject.replace(settings['subject'], '')
    # some shell protection
    #subject = subject.replace('`', "'")
    return subject.strip()


def get_attachments(message):
    """Extracts attachments from the message.
    
    Returns a list of tuples (filename, contents)."""
    result = []
    for i in message.walk():
        if i.is_multipart():
            continue
        if i.get_content_maintype() == 'text':
            continue
        att_name = decode_subject(i.get_filename(None))
        if att_name and os.path.splitext(att_name)[1].lower() in ('.wav', '.amr', '.mp3', '.ogg'):
            result.append((att_name, i.get_payload(decode=True)))
    return result


def fetch_raw_messages(settings):
    "Retrieves messages from the mailbox."
    client = poplib.POP3_SSL(settings['pop3_host'])
    client.user(settings['pop3_login'])
    client.pass_(settings['pop3_password'])

    result = []
    for msgid in client.list()[1]:
        delete = None
        try:
            number, length = msgid.split(' ', 1)
            headers = email.parser.Parser().parsestr('\n'.join(client.top(number, 0)[1]))

            if settings.get('to') in headers['to']:
                headers = client.retr(number)[1]
                message = email.parser.Parser().parsestr('\n'.join(headers))
                result.append(message)
                delete = number
                print 'Message #%s matches (%s bytes).' % (number, length)
            else:
                print 'Message #%s does not match.' % number
        except Exception, e:
            traceback.print_exc(e)
            logging.error('ERROR processing a message (%s): %s.' % (msgid, e))
        if delete is not None:
            client.dele(delete)

    if not settings.get('debug'):
        client.quit()

    return result


def extract_messages(messages):
    "Extracts files from the message."
    result = []

    for message in messages:
        subject = decode_subject(message['subject'])

        sender = rfc822.parseaddr(message['from'])[1]
        if message['X-Asterisk-CallerID']:
            sender = message['X-Asterisk-CallerID']
            subject = 'GSM hotline'

        attachments = get_attachments(message)
        print 'Message "%s" has %u files.' % (subject, len(attachments))

        for filepath, data in attachments:
            filename = tempfile.mkstemp(prefix=TMPREFIX, suffix=os.path.splitext(filepath)[1].lower())[1]
            f = open(filename, 'wb')
            f.write(data)
            f.close()
            result.append({ 'sender': sender, 'subject': subject, 'filename': filename })
    return result


def transcode(filenames):
    "Combines all input files to one WAV file."
    tmps = []
    for filename in filenames:
        tmps.append(tempfile.mkstemp(prefix=TMPREFIX, suffix='.wav')[1])
        run(['ffmpeg', '-i', filename, '-ar', '44100', '-ac', '2', '-y', tmps[-1]])

    output = tempfile.mkstemp(prefix=TMPREFIX, suffix='.ogg')[1]
    run(['sox'] + tmps + [output, 'norm'])
    os.chmod(output, 0664)

    for tmp in tmps:
        os.unlink(tmp)

    return output


def transcode_messages(messages, settings):
    result = []
    for message in messages:
        filenames = [ settings.getpath('prepend'), message['filename'], settings.getpath('append') ]
        combined = transcode([fn for fn in filenames if fn])

        # Calculate ReplayGain.
        run([ 'vorbisgain', combined ])

        m = mutagen.File(combined)
        m['artist'] = message['sender']
        m['title'] = message['subject']
        m.save()

        os.unlink(message['filename'])
        message['filename'] = combined
        result.append(message)

    return result


def fetch_messages(settings):
    """Scans the mail box for messages.

    Returns a list of dictionaries with keys: author, subject, filename.  Each
    file is a temporary file which should be deleted after processing."""

    result = []
    for message in transcode_messages(extract_messages(fetch_raw_messages(settings)), settings):
        result.append(message)
    return result


def upload_messages(messages, settings):
    ssh_login = settings.get('ssh_login')
    ssh_path = settings.get('ssh_path')

    if ssh_login and ssh_path:
        ssh_command = [ 'ssh' ]
        scp_command = [ 'scp' ]

        keyfile = settings.getpath('ssh_key')
        if keyfile:
            ssh_command += [ '-i', keyfile ]
            scp_command += [ '-i', keyfile ]

        for message in messages:
            if os.path.exists(message['filename']):
                target = os.path.join(ssh_path, os.path.basename(message['filename'] ))
                run(scp_command + [ message['filename'], ssh_login + ':' + ssh_path ])
                run(ssh_command + [ ssh_login, 'ardj --tags=voicemail --queue --add ' + target])
                if not settings.get('debug'):
                    os.unlink(message['filename'])


if __name__ == '__main__':
    settings = ardj.settings.load('voicemailer')
    if settings is None:
        sys.exit(0)

    msgs = fetch_messages(settings)
    upload_messages(msgs, settings)
