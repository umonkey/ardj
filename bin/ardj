#!/usr/bin/env python
# vim: set ts=4 sts=4 sw=4 et fileencoding=utf-8:

import os
import sys

import ardj.log

def usage():
    print "Usage: %s [options]" % os.path.basename(sys.argv[0])
    print "\nCommand options:"
    print " --add        adds tracks to the database"
    print " --backup     save metadata to file tags"
    print " --next       show next track"
    print " --update     update database"
    print ""
    print "Control options:"
    print " --debug      enable extra logging"
    print " --delete     delete files after --adding"
    print " --queue      queue tracks after --adding"
    print " --quiet      suppress log messages (stderr)"
    print " --scrobble   scrobble track (only makes sense with --next)"
    print " --tags       specify tags for --add"
    return 1

def oldstyle():
    import getopt
    from ardj import Open
    ardj = Open()

    try:
        opts, args = getopt.getopt(sys.argv[1:], 'i', ['add', 'backup', 'debug', 'delete', 'next', 'quiet', 'queue', 'scrobble', 'tags=', 'update'])
    except getopt.GetoptError:
        sys.exit(usage())

    if not len(opts):
        sys.exit(usage())

    tags = []
    queue = delete = False

    # prepare for work
    for option, value in opts:
        if '--quiet' == option:
            sys.stderr = None
        if '--debug' == option:
            ardj.debug = True
        if '--delete' == option:
            delete = True
        if '--tags' == option:
            tags = value.split(',')
        if '--queue' == option:
            queue = True

    for option, value in opts:
        if '--add' == option:
            for filename in args:
                if os.path.exists(filename):
                    ardj.add_file(filename, {'labels':tags, 'owner': 'console'}, queue=queue)
                    if delete:
                        os.unlink(filename)
            ardj.database.commit()
            args = []
        if '--backup' == option:
            import db
            idx, tracks = 1, db.track.get_all()
            for track in tracks:
                if os.path.exists(track.path):
                    print '%u/%u\r' % (idx, len(tracks)),
                    sys.stdout.flush()
                    track.backup()
                idx += 1
            print
        if '--next' == option:
            scrobble = ('--scrobble', '') in opts
            track = ardj.get_next_track(scrobble=scrobble)
            if track is None:
                print >>sys.stderr, 'Could not find a track to play.'
                sys.exit(1)
            print track['filepath']
        if '--update' == option:
            ardj.sync()

COMMAND_MAP = [ # (command, module, function, description)
    ('client', 'client', 'run_cli', 'run the client'),
    ('config', 'settings', 'edit_cli', 'edit settings'),
    ('count-ears', 'ears', 'aggregate', 'aggregates play counts'),
    ('db', 'database', 'run_cli', 'database functions'),
    ('events', 'tout', 'run_cli', 'works with the upcoming events'),
    ('find-orphans', 'orphans', 'mark', 'marks tracks that don\'t belong to any playlist'),
    ('hotline', 'hotline', 'run_cli', 'work with the hotline'),
    ('icelog', 'icelogger', 'run_cli', 'work with Icecast logs'),
    ('jabber', 'jabber', 'run_cli', 'run the jabber bot'),
    ('listeners', 'listeners', 'run_cli', 'summarizes listeners.csv'),
    ('mail', 'mail', 'run_cli', 'send or receive mail'),
    ('map-listeners', 'map', 'update_listeners', 'updates the listeners map'),
    ('news', 'news', 'update', 'updates news from echo.msk.ru'),
    ('podcaster', 'podcast', 'run_cli', 'fetch new podcasts'),
    ('rg', 'replaygain', 'run_cli', 'scan ReplayGain in files'),
    ('say', 'speech', 'render_text_cli', 'renders text to voice using festival, then plays it'),
    ('stream', 'stream', 'run_cli', 'handles stream events'),
    ('tsn', 'tsn', 'run', 'prepare and process a new So-So-News episode'),
    ('twit', 'twitter', 'twit', 'interacts with the twitter account'),
]

def find_command(command_name):
    for cmd, mod, fun, doc in COMMAND_MAP:
        if command_name == cmd:
            try:
                m = __import__('ardj.' + mod)
                m = getattr(m, mod)
                f = getattr(m, fun)
                return f
            except Exception, e:
                ardj.log.error('Command "ardj %s" is broken: %s' % (cmd, e))


    print 'Unknown command: "%s", available commands:' % command_name
    for cmd, mod, fun, doc in sorted(COMMAND_MAP, key=lambda x: x[0]):
        print '  %-20s   %s' % (cmd, doc)
    sys.exit(1)

if __name__ == '__main__':
    if len(sys.argv) >= 2 and not sys.argv[1].startswith('-'):
        handler = find_command(sys.argv[1])
        if handler is not None:
            try:
                sys.exit(handler(sys.argv[2:]) and 0 or 1)
            except Exception, e:
                ardj.log.error('ERROR handling command %s: %s' % (sys.argv[1], e))
                sys.exit(1)
        ardj.log.error('Unknown command: %s' % sys.argv[1])
        sys.exit(1)
    oldstyle()
