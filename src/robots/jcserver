#!/usr/bin/env python
# vim: set fileencoding=utf-8:

"""Multi-user chat server for the MUC web interface.

Reads messages of the "nickname text..." form from a fifo, spawns a new client
for each new nickname, sends the messages out.

Configuration is read from ~/.jcserver, which must be a text file containing 4
words: your jid, jabber password, jabber chat room and the fifo to use.  Example:

  alice@example.com secret tmradio@conference.jabber.ru /tmp/jcserver.fifo

To send a message:

  echo "alice_1 hello, world." > /tmp/jcserver.fifo

To shut down the server press ^C.

This version uses JabberBot from the ardj package.  To run without installing
the package use this command:

  PYTHONPATH=../ ./jcserver
"""

import os
import socket
import sys
import threading
import time
import xmpp
from ardj.jabberbot import JabberBot, botcmd

JABBER_LOGIN = None
JABBER_PASSWORD = None
JABBER_NICK = 'chat-server'
JABBER_CHAT_ROOM = None
JABBER_FIFO = None
JABBER_TIMEOUT = 600

shutting_down = False

class ChatClient(JabberBot):
    def __init__(self, *args, **kwargs):
        nickname = kwargs['nickname']
        del kwargs['nickname']
        JabberBot.__init__(self, *args, **kwargs)
        self.nickname = nickname
        self.messages = []
        self.lastmsg = time.time()
        self.join()

    def join(self):
        self.connect().send(xmpp.Presence(JABBER_CHAT_ROOM + u'/' + self.nickname))

    def leave(self):
        msg = xmpp.Presence()
        msg.setTo(JABBER_CHAT_ROOM + u'/' + self.nickname)
        msg.setType('unavailable')
        self.connect().send(msg)

    def post_message(self, message):
        self.messages.append(message)
        self.lastmsg = time.time()

    def idle_proc(self):
        shutdown = shutting_down
        if time.time() - self.lastmsg > JABBER_TIMEOUT:
            print '%s timed out' % self.nickname
            shutdown = True
        if shutdown:
            self.leave()
            self.quit(1)
        elif self.messages:
            text = self.messages.pop()
            msg = xmpp.protocol.Message(body=text)
            msg.setTo(JABBER_CHAT_ROOM)
            msg.setType('groupchat')
            self.connect().send(msg)


class client(threading.Thread):
    def __init__(self, nickname, on_end):
        threading.Thread.__init__(self)
        self.nickname = nickname
        self.on_end = on_end
        self.cli = ChatClient(JABBER_LOGIN, JABBER_PASSWORD, nickname=self.nickname, res=self.nickname, debug=False)
        self.start()

    def post_message(self, message):
        self.cli.post_message(message)

    def run(self):
        print 'Client %s thread started.' % self.nickname
        self.cli.serve_forever()
        print 'Client %s thread stopped.' % self.nickname
        self.on_end()
        del self.cli


class server(object):
    def __init__(self):
        self.clients = {}

    def run(self):
        fname = JABBER_FIFO
        if os.path.exists(fname):
            os.unlink(fname)
        os.mkfifo(fname)
        try:
            f = open(fname, 'rb')
            while True:
                data = f.read(1024)
                if data:
                    parts = data.strip().split(' ', 1)
                    if len(parts) == 2:
                        nickname, message = parts
                        if not self.clients.has_key(nickname):
                            self.clients[nickname] = client(nickname, on_end=lambda: self.detach(nickname))
                        self.clients[nickname].post_message(message)
        finally:
            if os.path.exists(fname):
                os.unlink(fname)

    def detach(self, nickname):
        if self.clients.has_key(nickname):
            print 'Detaching %s' % nickname
            del self.clients[nickname]


if __name__ == '__main__':
    data = open(os.path.expanduser('~/.jcserver'), 'rb').read().strip().split(' ')
    JABBER_LOGIN, JABBER_PASSWORD, JABBER_CHAT_ROOM, JABBER_FIFO = data[0:4]

    try:
        server().run()
    except KeyboardInterrupt:
        shutting_down = True
