#!/usr/bin/env python
# vim: set fileencoding=utf-8:

from lxml import etree
import csv
import datetime
import os
import re
import subprocess
import sys
import time
import urllib
import urllib2

COMMON_LABEL = 'music'
ARTIST_NAME_STRIP = re.compile(u'[^a-z0-9а-я]+', re.IGNORECASE|re.UNICODE)

settings = None

def get_artist_names():
    cur = ardj.Open().database.cursor()
    names = [row[0] for row in cur.execute('SELECT DISTINCT artist FROM tracks WHERE id IN (SELECT track_id FROM labels WHERE label = ?)', (COMMON_LABEL, )).fetchall()]
    # Select lowercase names, not rows.
    ## names = [names.lower() for row in names]
    # Delete duplicates.
    names = list(set(names))
    # Sort and get out.
    return sorted(names)

def get_events(names):
    print '%u artists found.' % len(names)
    result = []
    first = lambda x: x and x[0] or None
    for name in names:
        url = 'http://ws.audioscrobbler.com/2.0/?method=artist.getevents&artist=%s&api_key=%s' % (urllib.quote(name.encode('utf-8')), settings['key'])
        try:
            xml = urllib2.urlopen(urllib2.Request(url)).read()
            doc = etree.XML(xml)
            events = doc.xpath('/lfm/events/event')
            for event in events:
                country = first(event.xpath('venue/location/country/text()'))
                city = first(event.xpath('venue/location/city/text()'))
                date = first(event.xpath('startDate/text()'))
                result.append([name, date, country, city])
            print '%02u events for %s' % (len(events), name)
        except Exception, e:
            print >>sys.stderr, u'Could not read events for %s: %s' % (name, e)
    return result

def update_events_csv():
    filename = settings['events.csv']

    if os.path.exists(filename):
        if time.time() - os.stat(filename).st_mtime < 600:
            return
    f = open(filename, 'wb')
    out = csv.writer(f)
    events = get_events(get_artist_names())
    for event in events:
        out.writerow([cell and cell.encode('utf-8') or '' for cell in event])
    f.close()

def get_event_map():
    result = {}
    csvname = settings['events.csv']
    update_events_csv()

    countries = settings.has_key('event_countries') and settings['event_countries'] or ('Russian Federation', )

    for row in csv.reader(open(csvname, 'rb')):
        name = row[0].decode('utf-8')
        city = row[3].decode('utf-8').split(',')[0]
        if row[2].decode('utf-8') in countries:
            date = datetime.datetime.strptime(row[1][:16], '%a, %d %b %Y').strftime('%Y-%m-%d')
            if not result.has_key(date):
                result[date] = {}
            result[date][name] = city
    return result


def dump_event_map(m):
    for date in sorted(m.keys()):
        print date
        for artist in m[date].keys():
            print '  %s, %s' % (artist, m[date][artist])


def get_speech(events):
    months = [u'января', u'февраля', u'марта', u'апреля', u'мая', u'июня', u'июля', u'августа', u'сентября', u'октября', u'ноября', u'декабря']
    days = [u'первого', u'второго', u'третьего', u'четвёртого', u'пятого', u'шестого', u'седьмого', u'восьмого', u'девятого', u'десятого', u'одиннадцатого', u'двенадцатого', u'тринадцатого', u'четырнадцатого', u'пятнадцатого', u'шестнадцатого', u'семнадцатого', u'восемнадцатого', u'девятнадцатого', u'двадцатого', u'двадцать первого', u'двадцать второго', u'двадцать третьего', u'двадцать четвёртого', u'двадцать пятого', u'двадцать шестого', u'двадцать седьмого', u'двадцать восьмого', u'двадцать девятого', u'тридцатого', u'тридцать первого']

    now = datetime.datetime.now()

    output = u'Прослушайте афишу концертов на ближайшие две недели.'
    for date in sorted(events.keys()):
        date_ = datetime.datetime.strptime(date, '%Y-%m-%d')
        if (date_ - now).days < 14:
            for artist in events[date].keys():
                artist_name = xlat('artist_names', artist, ARTIST_NAME_STRIP.sub(lambda a: ' ', artist).strip())
                city_name = xlat('city_names', events[date][artist])
                if city_name:
                    output += u'  %s %s, %s, %s.' % (days[date_.day - 1], months[date_.month - 1], artist_name, city_name)
    output += u'  Подробную информацию можно найти на сайте ласт эф эм.  Спасибо за внимание.  Слава роботам.  Ха.'
    return output


def speak_event_map(events):
    filename = settings['events.csv']
    filename_txt = filename + '.txt'
    filename_wav = filename + '.wav'

    if settings.has_key('events_ogg'):
        filename_ogg = settings['events_ogg']
    else:
        filename_ogg = filename + '.ogg'

    open(filename_txt, 'wb').write(get_speech(events).encode('utf-8'))
    subprocess.Popen(['text2wave', '-eval', '(voice_msu_ru_nsh_clunits)', filename_txt, '-o', filename_wav]).wait()
    subprocess.Popen(['oggenc', '-Q', '-q', '9', '--resample', '44100', '-a', 'Говорящий робот', '-t', u'Расписание концертов', '-o', filename_ogg, filename_wav]).wait()

    print 'Wrote output to %s' % filename_ogg
    os.unlink(filename_wav)


def xlat(key, value, default=None):
    if settings.has_key(key) and settings[key].has_key(value):
        return settings[key][value]
    if default is None:
        default = value
    return default


if __name__ == '__main__':
    if not os.path.abspath(sys.argv[0]).startswith('/usr'):
        src_dir = os.path.abspath(os.path.join(os.path.dirname(sys.argv[0]), '..'))
        sys.path.insert(0, src_dir)

    import ardj
    import ardj.settings

    settings = ardj.settings.load('last.fm')

    speak_event_map(get_event_map())
